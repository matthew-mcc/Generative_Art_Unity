// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Start
#pragma kernel Update

// Create a RenderTexture with enableRandomWrite flag and set it
// with cs.SetTexture

RWTexture2D<float4> currentGrid;
RWTexture2D<float4> nextGrid;
RWTexture2D<float4> displayGrid;

Texture2D<float4> initMap;

// Parameters from karl sims (using the Gray-Scott model)
float deltaTime;
int width;
int height;

float feedRate;
float killRate;

float diffusionRateA;
float diffusionRateB;

int colorMode;
int directionalMode;
int numberDirectionalSegments; // default 20
float directionalBiasModifier; // default 0.005
// (1, 0) means we will bias to the right
// (0, 1) means we will bias downward
// (1, 1) means we will bias diagonally

// 0 Means no orientation change
// 1 --> (1, 0)
// 2 --> (0, 1)
// 3 --> (1, 1)
int orientationDirection = 0; 
float2 diffusionDirection = float2(1, 1);


// Initialization kernel
[numthreads(8,8,1)]
void Start (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height){
        return;
    }

    // This works, need to create some initial maps tho...
    float4 initVals = initMap[id.xy];
    currentGrid[id.xy] = float4(1, initVals.r, 0, 0);

    // ============ Testing Random =============


    // ============ 3 Diagonal Squares =============

    // Initialize A, B with default values
    // float4 cell = float4(1.0, 0.0, 0.0, 0.0); // float4(A, B, 0, 0)

    // // Define multiple reaction-diffusion points
    // int2 centers[3] = { int2(width / 2, height / 2), int2(width / 4, height / 4), int2(3 * width / 4, 3 * height / 4) };
    // int regionSize = 5;

    // // Check each region for initialization of B concentration
    // for (int i = 0; i < 3; i++) {
    //     int centerX = centers[i].x;
    //     int centerY = centers[i].y;
    //     if ((id.x > centerX - regionSize && id.x < centerX + regionSize) &&
    //         (id.y > centerY - regionSize && id.y < centerY + regionSize)) {
    //         cell.y = 1.0;  // Initialize B for reaction
    //         break;         // Exit once one region is assigned
    //     }
    // }

    // currentGrid[id.xy] = cell;

    // ============= Single Circle =============
    // float4 cell = float4(1.0, 0.0, 0.0, 0.0); // float4(A, B, 0, 0)

    // // Add a small amount of B for reaction to start
    // float centerX = width / 2.0; // Ensure floating-point division
    // float centerY = height / 2.0; // Ensure floating-point division
    // float radius = 15.0;

    // float dx = id.x - centerX; // id.x and id.y need to be treated as floats
    // float dy = id.y - centerY;

    // // Check if the cell is within the circle
    // if ((dx * dx) + (dy * dy) < (radius * radius)) {
    //     cell.y = 1.0;
    // }

    // currentGrid[id.xy] = cell;
    // ============= Single Square =============
    
    // // Initialize A, B with default values
    // float4 cell = float4(1.0, 0.0, 0.0, 0.0); // float4(A, B, 0, 0)

    // // Add a small amount of B for reaction to start
    // int centerX = width / 2;
    // int centerY = height / 2;

    // if ((id.x > centerX - 15 && id.x < centerX + 15) && (id.y > centerY - 15 && id.y < centerY + 15)) {
    //     cell.y = 1.0;
    // }

    // currentGrid[id.xy] = cell;
    

    // ============ Triangle ============
    
    // Initialize cell with A = 1.0 and B = 0.0
    // float4 cell = float4(1.0, 0.0, 0.0, 0.0); // float4(A, B, 0, 0)

    // // Define center and radius for the circle
    // int centerX = width / 2;
    // int centerY = height / 2;
    // float radius = 15.0; // Radius of the circle

    // // Calculate distance from the center
    // float distance = length(float2(id.x - centerX, id.y - centerY));

    // // Check if the current pixel is within the circle's radius
    // if (distance < radius) {
    //     cell.y = 1.0; // Set B to 1.0 inside the circle
    // }

    // // Store the cell in the current grid
    // currentGrid[id.xy] = cell;
    
}

float CalculateLaplacianA(int2 id) {
    // 3x3 convolution weights for Laplacian
    float4 center = currentGrid[id.xy];
    float a = center.x;
    
    float laplacianA = -a; // Center weight is -1
    
    // Define offsets for 3x3 neighborhood
    int2 offsets[8] = {
        int2(0, 1),    // up
        int2(1, 0),    // right
        int2(0, -1),   // down
        int2(-1, 0),   // left
        int2(1, 1),    // up-right
        int2(-1, 1),   // up-left
        int2(1, -1),   // down-right
        int2(-1, -1)   // down-left
    };
    
    float weights[8] = {0.2, 0.2, 0.2, 0.2, 0.05, 0.05, 0.05, 0.05};
    
    // Accumulate weighted sum of neighbors
    for (int i = 0; i < 8; i++) {
        int2 neighborPos = id + offsets[i];
        float sqrDst = offsets[i].x * offsets[i].x * offsets[i].y * offsets[i].y;
        neighborPos = clamp(neighborPos, int2(0, 0), int2(width - 1, height - 1));
        laplacianA += currentGrid[neighborPos].x * weights[i];
        
    }

    return laplacianA;
}

float CalculateLaplacianB(int2 id) {
    // 3x3 convolution weights for Laplacian
    float4 center = currentGrid[id.xy];
    float b = center.y;
    
    float laplacianB = -b; // Center weight is -1
    
    // Define offsets for 3x3 neighborhood
    int2 offsets[8] = {
        int2(0, 1),    // up
        int2(1, 0),    // right
        int2(0, -1),   // down
        int2(-1, 0),   // left
        int2(1, 1),    // up-right
        int2(-1, 1),   // up-left
        int2(1, -1),   // down-right
        int2(-1, -1)   // down-left
    };
    
    float weights[8] = {0.2, 0.2, 0.2, 0.2, 0.05, 0.05, 0.05, 0.05};
    
    // Accumulate weighted sum of neighbors
    for (int i = 0; i < 8; i++) {
        int2 neighborPos = id + offsets[i];
        neighborPos = clamp(neighborPos, int2(0, 0), int2(width - 1, height - 1));
        laplacianB += currentGrid[neighborPos].y * weights[i];
    }

    return laplacianB;
}



[numthreads(8,8,1)]
void Update (uint3 id : SV_DispatchThreadID)
{
    if (id.x >= width || id.y >= height) {
        return;
    }
    
    float2 gridCenter = float2(width / 2.0, height / 2.0);
    float2 currentPos = float2(id.x, id.y);
    
    // Determine kill rate variation mode
    // int directionalMode = 2; // 0 = radial, 1 = sine wave, 2 = columns, 3 = normal
    
    
    // int linearMode = 0; // 0 = horizontal, 1 = vertical, 2 = diagonal
    
    float varyingKillRate;
    
    // None
    if (directionalMode == 0){
        varyingKillRate = killRate;
    }
    
    // Linear - horizontal
    else if (directionalMode == 1){
        float columnWidth = width / numberDirectionalSegments;
        varyingKillRate = (fmod(currentPos.y, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    }
    // Linear - vertical
    else if (directionalMode == 2){
        float columnWidth = width / numberDirectionalSegments;
        varyingKillRate = (fmod(currentPos.x, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    }
    // Linear - diagonal
    else if (directionalMode == 3){
        float columnWidth = width / numberDirectionalSegments;
        varyingKillRate = (fmod(currentPos.x + currentPos.y, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    }
    // Radial
    else if (directionalMode == 4){
        float distanceFromCenter = length(currentPos - gridCenter);
        float maxDistance = length(gridCenter);
        float normalizedDistance = distanceFromCenter / maxDistance;
        varyingKillRate = lerp(killRate, killRate + directionalBiasModifier, normalizedDistance);
    }
    // Sinusoidal
    else if (directionalMode == 5){
        varyingKillRate = lerp(killRate, killRate + directionalBiasModifier, 0.5 * (sin(currentPos.x * 0.5) + 1.0)); // Adjust 0.1 for wavelength
    }
    // none
    // if (mode == 0) {
    //     // Radial gradient
    //     float distanceFromCenter = length(currentPos - gridCenter);
    //     float maxDistance = length(gridCenter);
    //     float normalizedDistance = distanceFromCenter / maxDistance;
    //     varyingKillRate = lerp(killRate, killRate + directionalBiasModifier, normalizedDistance);
        
    // } else if (mode == 1) { // BROKEN!
    //     // Sine wave variation (horizontal)
    //     varyingKillRate = lerp(killRate, killRate + directionalBiasModifier, 0.5 * (sin(currentPos.x * 0.5) + 1.0)); // Adjust 0.1 for wavelength
    // } else if (mode == 2) {
    //     // Column variation
    //     float columnWidth = width / numberLines; // Divide grid into 10 columns
    //     if (linearMode == 0){
    //         varyingKillRate = (fmod(currentPos.y, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    //     }
    //     else if (linearMode == 1){
    //         varyingKillRate = (fmod(currentPos.x, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    //     }
    //     else if (linearMode == 2){
    //         varyingKillRate = (fmod(currentPos.x + currentPos.y, columnWidth) < (columnWidth / 2.0)) ? killRate : killRate + directionalBiasModifier;
    //     }

    // }
    // else if (mode == 3){
    //     varyingKillRate = killRate;
    // }
    
    // Get current A, B values
    float2 currentValues = currentGrid[id.xy].xy;
    float a = currentValues.x;
    float b = currentValues.y;
    
    // Calculate Laplacians for A and B
    float laplacianA = CalculateLaplacianA(id.xy);
    float laplacianB = CalculateLaplacianB(id.xy);
    
    // Gray-Scott reaction-diffusion equations with varying kill rate
    float reaction = a * b * b;
    float diffA = (diffusionRateA * laplacianA - reaction + feedRate * (1.0 - a));
    float diffB = (diffusionRateB * laplacianB + reaction - (varyingKillRate + feedRate) * b);
    
    // Update concentrations
    float newA = a + diffA;
    float newB = b + diffB;
    
    // Update next grid state
    nextGrid[id.xy] = float4(max(0, newA), min(newB, 1), diffA, diffB);
    
    // float2 diffuseStrength = 0;

    // float2 sum = 0;
    // float weightSum;
    // int diffuseRadius = 6;
    // for(int offsetY = -diffuseRadius; offsetY <= diffuseRadius; offsetY ++ ){
    //     for (int offsetX = -diffuseRadius; offsetX <= diffuseRadius; offsetX ++){
    //         if (offsetX == 0 && offsetY == 0){
    //             continue;
    //         }
    //         int2 samplePos = id.xy + int2(offsetX, offsetY);
    //         samplePos = min(int2(width-1, height-1), max(0, samplePos));
    //         float sqrDst = offsetX * offsetX * offsetY * offsetY;

    //         if (sqrDst <= diffuseRadius * diffuseRadius){
    //             float weight = 1.0 / sqrt(sqrDst);
    //             sum += currentGrid[samplePos].xy * weight;
    //             weightSum += weight;
    //         }
    //     }
    // }

    // diffuseStrength = sum / weightSum - currentValues;

    // float deltaA = (diffusionRateA * diffuseStrength.x - a * b * b + feedRate * (1-a));
	// float newA = a + deltaA;

	// float deltaB = (diffusionRateB * diffuseStrength.y + a * b * b - (killRate + feedRate) * b);
	// float newB = b + deltaB;

    // nextGrid[id.xy] = float4(max(0, newA), min(newB, 1), deltaA, deltaB); // Update next grid state

    

    float colorA = nextGrid[id.xy].x;
    float colorB = nextGrid[id.xy].y;
    float colorW = nextGrid[id.xy].w;
    float colorZ = nextGrid[id.xy].z;
    
    // Standard
    if (colorMode == 0){
        displayGrid[id.xy] = nextGrid[id.xy];
    }

    // Black and White
    else if (colorMode == 1){
        displayGrid[id.xy] = colorA - colorB;
    }

    // Sebastian Lague Color
    else if (colorMode == 2){
        float v = colorA - colorB;

        displayGrid[id.xy] = (1 - pow(abs(1 - (v + 1 - max(colorW, colorZ) * 350)), 0.6)) + float4(colorW, 0, 0, 0) * 400;
    }

    // Sebastian Lague Color 2.0
    else if (colorMode == 3){
        float4 col = float4(colorZ * 350, colorW * 250, 0, 0) + float4(0, 0, colorB, 0);
        col = col.gbra;
        col.g = pow(col.g, 2) * 6;
        col = min(1, max(0, col));
        displayGrid[id.xy] = col;
    }

    // displayGrid[id.xy] = nextGrid[id.xy];   // Write to output for visualization
    

    
}