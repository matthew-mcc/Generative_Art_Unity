// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel CSMain
#pragma kernel CalculatePotential
#pragma kernel SelectGrowthSite
#pragma kernel UpdatePotential

// Output textures and buffers
RWTexture2D<float4> Result; // Likely depracated 
RWTexture2D<float> aggregateGrid;   // Texture representing the aggregate grid (1 means filled, 0 means empty)

// Buffers of charges and candidate positions
StructuredBuffer<float3> chargePositions;   // Positions of existing charges
StructuredBuffer<float3> candidatePositions; // Positions to calculate potentials for

// Buffers to store results
RWStructuredBuffer<float> potentialBuffer;   // Buffer to store calculated potentials for each candidate
RWStructuredBuffer<float> growthSiteBuffer;  // Buffer to store the selected growth site index

// Parameters
int numCharges;       // Number of charges
int numCandidates;    // Number of candidate positions
float R1;             // Radius constant for potential calculation
float eta;            // Parameter for probability calculation

// Main kernel (dummy kernel for testing setup)
[numthreads(8, 8, 1)]
void CSMain(uint3 id : SV_DispatchThreadID) {
    // Placeholder output to test shader execution, you can modify as needed
    Result[id.xy] = float4(id.x & id.y, (id.x & 15) / 15.0, (id.y & 15) / 15.0, 1.0);
}

// ======================================================================================= //

// Kernel to calculate potentials for each candidate position
[numthreads(1, 1, 1)]
void CalculatePotential(uint id : SV_DispatchThreadID) {
    if (id >= numCandidates) return; // Ensure we stay within bounds

    float potential = 0.0;

    // Calculate potential based on each charge position
    for (uint j = 0; j < numCharges; j++) {
        float distance = length(candidatePositions[id] - chargePositions[j]);
        // Avoid division by zero
        if (distance > 0.001) {
            potential += (1.0 - (R1 / distance));
        }
    }
    potentialBuffer[id] = potential;
}

// ======================================================================================= //

// Kernel to select a growth site based on normalized potentials and probability
[numthreads(1, 1, 1)]
void SelectGrowthSite(uint id : SV_DispatchThreadID) {
    if (id >= 1) return; // Run only once for selection

    float phi_min = potentialBuffer[0];
    float phi_max = potentialBuffer[0];

    // Find minimum and maximum potentials
    for (uint i = 1; i < numCandidates; i++) {
        phi_min = min(phi_min, potentialBuffer[i]);
        phi_max = max(phi_max, potentialBuffer[i]);
    }

    float sumPhi = 0.0;

    // Sum probabilities based on normalized potentials
    for (uint i = 0; i < numCandidates; i++) {
        float phi_i_norm = (potentialBuffer[i] - phi_min) / (phi_max - phi_min + 0.0001); // Avoid division by zero
        sumPhi += pow(phi_i_norm, eta);
    }

    // Generate random number for site selection
    float randomValue = frac(sin(dot(float2(id, id), float2(12.9898, 78.233))) * 43758.5453); // Simple random generation

    float cumulativeProb = 0.0;

    // Select a growth site based on cumulative probability
    for (uint i = 0; i < numCandidates; i++) {
        float phi_i_norm = (potentialBuffer[i] - phi_min) / (phi_max - phi_min + 0.0001);
        cumulativeProb += pow(phi_i_norm, eta) / sumPhi;

        if (randomValue < cumulativeProb) {
            growthSiteBuffer[0] = float(i); // Assign the selected site index
            break;
        }
    }
}

// ======================================================================================= //

// Kernel to update the potential of each candidate based on a new charge position
[numthreads(1, 1, 1)]
void UpdatePotential(uint id : SV_DispatchThreadID) {
    if (id >= numCandidates) return; // Ensure we stay within bounds

    float3 newChargePosition = chargePositions[0]; // Use the first position as a new charge for demo purposes
    float distance = length(candidatePositions[id] - newChargePosition);
    if (distance > 0.001) { // Avoid division by zero
        potentialBuffer[id] += (1.0 - (R1 / distance));
    }
}
